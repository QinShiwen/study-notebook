# 计算机网络学习笔记

计算机网络五层模型：应用层 / 传输层 / 网络层 / 数据链路层 / 物理层

### 初识

用户在浏览器中做输入目的URL，浏览器进程先处理用户输入信息，在浏览器内核种向服务器发出请求，获取服务器返回的请求后渲染最后完成页面加载。

![HTTP-start](D:\大四\前端开发实习学习准备\Frontend-projects\Notebook\Internet\pics\HTTP-start.jpg)

## 应用层

### HTTP

Hyper Text Transfer Protocol，超文本传输协议。定义了客户端和服务器之间交换报文的格式和方式。其分为**请求**和**响应**两部分，是简单可扩展的，是无状态协议。

HTTP 有两种连接模式，一种是持续连接，一种非持续连接。

- 非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。

- 持续连接下，TCP 连接默认不关闭，可以被多个请求复用。

- 采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。

- 在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live。来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持 同时建立 6 个持久连接。



#### 请求

**构成**

- 起始行：请求方式POST/GET，HTTP协议版本
- 请求头：请求头包含了一系列的键值对，用来传递请求的附加信息。常见的请求头字段包括Content-Type、User-Agent、Authorization等。请求头允许客户端向服务器传递额外的信息，以便服务器能够更好地理解和处理请求。
- 请求体：请求体是可选的，通常用于POST、PUT等请求方法中传递请求参数或数据。请求体中可以包含任意类型的数据，如表单数据、JSON数据等。

```http
GET /example/path HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
```

#### 请求方法

- GET：通常用于获取数据。
- POST：将实体提交到指定的服务器
- PUT：请求有效载荷替换目标资源
- DELETE：删除指定资源
- OPTIONS：描述目标资源通信选项
- 安全性：不会修改服务器数据的方法：GET/OPTIONS/HEAD，比较安全。
- 幂等性：同样请求被执行一次与连续多次效果是一样的，服务器状态也是一样的。比如：GET/HEAD/OPTIONS/PUT/DELETE



#### 响应

**构成**

- 起始行：HTTP协议的版本、状态码。
- 响应头：响应头包含了一系列的键值对，用于传递响应的附加信息。常见的响应头字段包括Content-Type、Content-Length、Cache-Control等。响应头提供了关于响应内容和服务器的一些元数据信息。
- 响应体：包含了服务器返回的实际内容。响应体的类型和格式取决于请求的性质和服务器的处理结果。对于HTML页面，响应体是HTML代码；对于图片，响应体是图片的二进制数据；对于JSON数据，响应体是JSON字符串等。

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1234

<!DOCTYPE html>
<html>
<head>
  <title>Example Page</title>
</head>
<body>
  <h1>Hello, world!</h1>
</body>
</html>
```



#### HTTP状态码

- 1xx（Informational）：信息性状态码，表示请求正在处理或需要进一步操作。
  - 100 Continue：服务器已接收到请求的一部分，客户端应继续发送剩余部分。
  - 101 Switching Protocols：服务器已收到请求，客户端应切换到指定的协议。
- 2xx（Success）：成功状态码，表示请求已成功被接收、理解和处理。
  - 200 OK：请求成功，服务器正常返回请求的内容。
  - 201 Created：请求成功，服务器创建了新资源。
  - 204 No Content：请求成功，服务器没有返回任何内容。
- 3xx（Redirection）：重定向状态码，表示需要进一步操作以完成请求。
  - 301 Moved Permanently：请求的资源已永久移动到新位置。
  - 302 Found：请求的资源暂时移动到新位置。
  - 304 Not Modified：客户端缓存的资源仍然有效，未修改。
- 4xx（Client Error）：客户端错误状态码，表示请求包含语法错误或无法完成请求。
  - 400 Bad Request：请求无效，服务器无法理解。
  - 403 Forbidden：服务器理解请求，但拒绝执行。
  - 404 Not Found：请求的资源不存在。
- 5xx（Server Error）：服务器错误状态码，表示服务器在处理请求时发生错误。
  - 500 Internal Server Error：服务器内部错误，无法完成请求。
  - 503 Service Unavailable：服务器暂时无法处理请求，通常是由于过载或维护。



#### HTTP常见首部字段

1. Content-Type：指定了请求或响应中所携带实体的媒体类型。对于请求，它表示请求体的数据类型；对于响应，它表示响应体的数据类型。常见的值包括 **application/json**、 **text/html**、 **image/jpeg** 等。
2. Content-Length：指定了请求或响应体的长度，以字节为单位。在响应中，它可以帮助客户端正确读取响应体的内容。
3. User-Agent：用于标识发送请求的用户代理（通常是浏览器）的信息。服务器可以使用该信息来**识别客户端类型和版本**，并根据需要进行适配或处理。
4. Accept：指定了客户端能够处理的响应内容类型的优先级顺序。服务器可以根据该首部字段来确定最适合的响应类型返回给客户端。
5. Authorization：用于**在请求中传递身份验证凭据**，通常用于访问受保护的资源。它包含了身份验证的类型和凭据信息，比如用户名和密码或访问令牌。
6. Cookie：在请求中传递已存储在客户端的HTTP Cookie。服务器可以使用Cookie来维护会话状态或记录用户的偏好设置。
7. Cache-Control：用于指定**请求或响应的缓存行为**。它可以控制缓存的存储、过期和重新验证策略，以提高性能并减少网络传输。
8. Location：用于重定向响应，指示客户端应该访问的新位置。通常与状态码3xx（重定向）一起使用。
9. If-Modified-Since：在请求中指定一个日期，用于与服务器上的资源的最后修改日期进行比较。服务器可以根据这个字段判断资源是否已被修改，如果没有修改，可以返回304 Not Modified状态码。
10. Referer：指示请求的来源页面的URL。服务器可以使用该信息来进行引荐统计、防盗链等操作。

![HTTP-store](D:\大四\前端开发实习学习准备\Frontend-projects\Notebook\Internet\pics\HTTP-store.jpg)



### HTTPS

HTTPS（Hypertext Transfer Protocol Secure）是一种通过加密和身份验证保护通信安全的HTTP协议。它使用**TLS**（Transport Layer Security）或其前身SSL（Secure Sockets Layer）协议来对HTTP通信进行加密和认证。

**TSL握手过程**

1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

![HTTPS-key](D:\大四\前端开发实习学习准备\Frontend-projects\Notebook\Internet\pics\HTTPS-key.jpg)



### DNS

Domain Name System，用于将域名转换成IP地址。

1. DNS预解析（DNS Prefetching）和预连接（Preconnect）的作用是什么？如何在网页中使用它们？

   DNS预解析通过在用户点击链接之前提前解析与当前页面相关的域名，以便在用户访问该页面时减少DNS查询的时间延迟。这可以通过在HTML文档中使用`<link>`标签并设置`rel="dns-prefetch"`来实现。例如：

   ```html
   <link rel="dns-prefetch" href="//example.com">
   ```

   预连接通过在当前页面加载完成后，提前建立与其他域名的TCP连接，以减少在用户需要时建立连接的时间延迟。这可以通过在HTML文档中使用`<link>`标签并设置`rel="preconnect"`来实现。例如：

   ```html
   <link rel="preconnect" href="//example.com">
   ```

2. 请解释一下域名解析的过程以及DNS查询的流程。

   - 用户在浏览器中输入域名并按下回车。
   - 操作系统的DNS解析器接收到域名请求。
   - 解析器首先检查本地缓存中是否存在对应的域名解析结果，如果存在且未过期，则返回缓存结果。
   - 如果缓存中不存在有效结果，解析器会向配置的本地DNS服务器发送查询请求。
   - 本地DNS服务器会根据请求查询其缓存，如果有匹配的记录，则返回给解析器。
   - 如果本地DNS服务器缓存中不存在匹配记录，则它会从根域名服务器开始递归查询，依次向下级域名服务器查询，直到找到负责目标域名的权威域名服务器。
   - 权威域名服务器返回域名解析结果给本地DNS服务器，本地DNS服务器将结果返回给解析器。
   - 解析器将结果返回给操作系统和浏览器，浏览器使用解析结果进行后续的网络连接。

3. 如何优化网站的DNS解析时间？

   - DNS预解析和预连接：使用DNS预解析和预连接技术，提前解析和建立与相关域名的连接，以减少后续访问时的DNS解析时间和连接建立时间。
   - 减少DNS查询次数：通过减少页面中需要解析的域名数量，可以降低DNS查询的时间延迟。合理使用域名合并、资源合并和CDN等技术，将页面中的资源集中在较少的域名下。
   - 设置适当的TTL值：通过设置适当的TTL（Time to Live）值，可以控制DNS记录在缓存中的存储时间。较短的TTL可以使DNS记录更频繁地从权威服务器获取更新，但会增加解析时间；较长的TTL可以减少解析时间，但权威服务器更新后的变更可能需要更长时间才能在客户端生效。



## 传输层

### TCP

TCP（Transmission Control Protocol，传输控制协议）是一种可靠的、面向连接的、基于字节流的传输层协议。TCP协议提供了数据传输的可靠性，保证了数据的准确传输和顺序传输，同时也实现了网络拥塞控制和流量控制等功能。

#### TCP三次握手

建立TCP连接时，客户端和服务器之间需要进行三次通信来确认连接的建立。

1. 第一次握手：客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的 随机数。它代表的是客户端数据的初始序号。
2. 第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向 客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认， 同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加 一。
3. 第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。第三次握手可以在报文段中携带数据。

**为什么要进行三次握手而不是其他次数？**

这个过程的目的是确保客户端和服务器都能够发送和接收到数据。需要三次握手的原因是为了**防止网络中存在已失效的连接请求**。

如果只进行两次握手，那么可能会出现下面这种情况：客户端发送SYN包，但是由于网络问题导致该包长时间未能到达服务器；此时客户端并未收到服务器的确认，但仍可以发送数据；当该数据到达服务器时，服务器会认为这是一个已经建立的连接，从而向客户端发送确认，但是此时客户端并没有建立连接，不会回复确认，导致服务器的资源浪费。通过三次握手可以避免这种问题。



#### TCP四次挥手

TCP连接的四次挥手是指在终止TCP连接时，客户端和服务器之间需要进行四次通信来完成连接的断开。

1. 第一次挥手：客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的连接。发送后客户端进入 FIN_WAIT_1 状态。
2. 第二次挥手：服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务器端进入 CLOSE_WAIT状态。客户端收到确认后，进入 FIN_WAIT_2 状态。
3. 第三次挥手：服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAST_ACK 状态。
4. 第四次挥手：客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间， 这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被 释放了。

TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以**需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。**

最后一次挥手中，**客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。**



## 网络层

网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选 择协议。

IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用 32 位来分配地址，还有 IPv6 使用 128 位来分配地址。

路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。



## 题目汇总

1. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？

   ```tcl
   （1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，
   将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字
   符，则对非法字符进行转义后再进行下一过程。
   
   （2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新
   的请求。
   
   （3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果
   有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域
   名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地
   址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用
   户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
   
   （4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源
   端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给
   数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地
   址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果
   在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该
   转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应
   该为网关的地址。
   
   （5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接
   收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的
   确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立
   状态，此时双方的连接就建立起来了。
   
   （6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版
   本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证
   书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后
   发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解
   密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加
   密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
   
   （7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行
   解析，开始页面的渲染过程。
   
   （8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端
   是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建
   立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页
   面进行绘制。这个时候整个页面就显示出来了。
   
   （9）最后一步是 TCP 断开连接的四次挥手过程。
   ```

2. 

